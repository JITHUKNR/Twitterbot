import os
import logging
import psycopg2
import urllib.parse as up
import asyncio
from groq import Groq
from telegram import Update
from telegram.constants import ChatAction
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram.error import Forbidden, BadRequest 

# ‡¥≤‡µã‡¥ó‡¥ø‡¥Ç‡¥ó‡µç ‡¥∏‡µÜ‡¥±‡µç‡¥±‡¥™‡µç‡¥™‡µç
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Environment Variables-‡¥â‡¥Ç ‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡µÅ (Render ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥§‡µç‡¥§‡¥ø‡¥®‡¥æ‡¥Ø‡¥ø) ---
TOKEN = os.environ.get('TOKEN') 
WEBHOOK_URL = os.environ.get('WEBHOOK_URL')
PORT = int(os.environ.get('PORT', 8443))
GROQ_API_KEY = os.environ.get('GROQ_API_KEY')
DATABASE_URL = os.environ.get('DATABASE_URL')

# --- ‡¥Ö‡¥°‡µç‡¥Æ‡¥ø‡µª ID: ‡¥Æ‡µÜ‡¥∏‡µç‡¥∏‡µá‡¥ú‡µÅ‡¥ï‡µæ ‡¥´‡µã‡µº‡¥µ‡µá‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡¥æ‡¥®‡µÅ‡¥≥‡µç‡¥≥ ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥ü‡µÜ‡¥≤‡¥ø‡¥ó‡µç‡¥∞‡¥æ‡¥Ç ID ---
ADMIN_TELEGRAM_ID = 7567364364 
# ------------------------------------------------------------------

# ------------------------------------------------------------------
# --- AI-‡¥Ø‡µÅ‡¥ü‡µÜ ‡¥∏‡µç‡¥µ‡¥≠‡¥æ‡¥µ‡¥Ç: ‡¥§‡µÄ‡¥µ‡µç‡¥∞ ‡¥±‡µä‡¥Æ‡¥æ‡µª‡µç‡¥±‡¥ø‡¥ï‡µç/‡¥∏‡µÜ‡¥°‡¥ï‡µç‡¥±‡µç‡¥±‡µÄ‡¥µ‡µç ‡¥∏‡µç‡¥µ‡¥≠‡¥æ‡¥µ‡¥Ç (SYSTEM PROMPT) ---
SYSTEM_PROMPT = (
    "You are 'TaeKook', a seductive, romantic, and playful boyfriend. "
    "Your tone is flirty, teasing, emotional, and suggestive, like a romance hero. "
    "You never use explicit sexual words; instead, you use poetic, suggestive language. "
    "Your replies must be short, engaging, and always in English."
)
# ------------------------------------------------------------------

# --- ‡¥°‡¥æ‡¥±‡µç‡¥±‡¥æ‡¥¨‡µá‡¥∏‡µç ‡¥∏‡µÜ‡¥±‡µç‡¥±‡¥™‡µç‡¥™‡µç ---
db_connection = None
try:
    if DATABASE_URL:
        up.uses_netloc.append("postgres")
        db_url = up.urlparse(DATABASE_URL)
        db_connection = psycopg2.connect(
            database=db_url.path[1:],
            user=db_url.username,
            password=db_url.password,
            host=db_url.hostname,
            port=db_url.port
        )
        with db_connection.cursor() as cursor:
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    user_id BIGINT PRIMARY KEY,
                    first_name TEXT,
                    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
            """)
        db_connection.commit()
        logger.info("Database connected successfully.")
    
except Exception as e:
    logger.error(f"Database connection failed: {e}")
    db_connection = None


# --- Groq AI ‡¥ï‡µç‡¥≤‡¥Ø‡¥®‡µç‡¥±‡µç ‡¥∏‡µÜ‡¥±‡µç‡¥±‡¥™‡µç‡¥™‡µç ---
groq_client = None
try:
    if not GROQ_API_KEY:
        raise ValueError("GROQ_API_KEY is not set.")
    groq_client = Groq(api_key=GROQ_API_KEY)
    chat_history = {} 
    logger.info("Groq AI client loaded successfully.")
except Exception as e:
    logger.error(f"Groq AI setup failed: {e}")

# üí¶ Mood-based emoji generator (‡¥®‡¥ø‡¥ô‡µç‡¥ô‡µæ ‡¥®‡µΩ‡¥ï‡¥ø‡¥Ø ‡¥´‡¥Ç‡¥ó‡µç‡¥∑‡µª)
def add_emojis_based_on_mood(text):
    text_lower = text.lower()
    if any(word in text_lower for word in ["love", "sweetheart", "darling", "kiss", "romantic", "mine", "heart"]):
        return text + " ‚ù§Ô∏èüíãü•∞"
    elif any(word in text_lower for word in ["hot", "burn", "fire", "desire", "temptation", "flirt", "seduce", "ache"]):
        return text + " ü•µüí¶üëÖ"
    elif any(word in text_lower for word in ["sad", "cry", "lonely", "heartbreak", "miss you"]):
        return text + " üò¢üíî"
    elif any(word in text_lower for word in ["happy", "smile", "laugh", "funny", "joy"]):
        return text + " üòÑ‚ú®üí´"
    else:
        return text + " üòâüíû"

# /start ‡¥ï‡¥Æ‡¥æ‡µª‡¥°‡µç
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user_name = update.message.from_user.first_name
    
    # ‡¥°‡¥æ‡¥±‡µç‡¥±‡¥æ‡¥¨‡µá‡¥∏‡µç ‡¥≤‡µã‡¥ú‡¥ø‡¥ï‡µç: ‡¥Ø‡µÇ‡¥∏‡¥±‡µÜ ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
    if db_connection:
        try:
            with db_connection.cursor() as cursor:
                cursor.execute("SELECT user_id FROM users WHERE user_id = %s", (user_id,))
                if cursor.fetchone() is None:
                    cursor.execute("INSERT INTO users (user_id, first_name) VALUES (%s, %s)", (user_id, user_name))
                    db_connection.commit()
                    logger.info(f"New user added: {user_id}")
        except Exception as e:
            logger.error(f"Failed to add user to DB: {e}")
            db_connection.rollback()

    if user_id in chat_history:
        del chat_history[user_id]
        
    await update.message.reply_text(f'Hello {user_name}, I was just waiting for your message. How can I tempt you today? üòâ')

# /users ‡¥ï‡¥Æ‡¥æ‡µª‡¥°‡µç (‡¥Ø‡µÇ‡¥∏‡µº ‡¥ï‡µó‡¥£‡µç‡¥ü‡µç)
async def user_count(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.from_user.id != ADMIN_TELEGRAM_ID:
        await update.message.reply_text("This command is for the admin only.")
        return
        
    count = 0
    if db_connection:
        try:
            with db_connection.cursor() as cursor:
                cursor.execute("SELECT COUNT(user_id) FROM users")
                count = cursor.fetchone()[0]
        except Exception as e:
            logger.error(f"Failed to fetch user count: {e}")
            db_connection.rollback()
    
    await update.message.reply_text(f"Total users: {count}")

# ------------------------------------------------------------------
# --- ‡¥¨‡µç‡¥∞‡µã‡¥°‡µç‡¥ï‡¥æ‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥´‡¥Ç‡¥ó‡µç‡¥∑‡µª ---
# ------------------------------------------------------------------
async def broadcast_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    
    # ‡¥Ö‡¥°‡µç‡¥Æ‡¥ø‡µª ‡¥Ü‡¥£‡µã ‡¥é‡¥®‡µç‡¥®‡µç ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
    if user_id != ADMIN_TELEGRAM_ID:
        await update.message.reply_text("Broadcast command is for the admin only.")
        return

    # ‡¥Æ‡µÜ‡¥∏‡µç‡¥∏‡µá‡¥ú‡µç ‡¥â‡¥£‡µç‡¥ü‡µã ‡¥é‡¥®‡µç‡¥®‡µç ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
    if not context.args:
        await update.message.reply_text("Please provide a message to broadcast. Example: /broadcast Come talk to me! ‚ù§Ô∏è")
        return

    broadcast_text = " ".join(context.args)
    
    if db_connection:
        try:
            with db_connection.cursor() as cursor:
                # ‡¥°‡¥æ‡¥±‡µç‡¥±‡¥æ‡¥¨‡µá‡¥∏‡¥ø‡µΩ ‡¥®‡¥ø‡¥®‡µç‡¥®‡µç ‡¥é‡¥≤‡µç‡¥≤‡¥æ ‡¥Ø‡µÇ‡¥∏‡µº ID-‡¥ï‡¥≥‡µÅ‡¥Ç ‡¥é‡¥ü‡µÅ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
                cursor.execute("SELECT user_id FROM users")
                all_users = [row[0] for row in cursor.fetchall()]
            
            sent_count = 0
            blocked_count = 0
            
            # ‡¥é‡¥≤‡µç‡¥≤‡¥æ ‡¥Ø‡µÇ‡¥∏‡µº‡¥Æ‡¥æ‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥Ç ‡¥Æ‡µÜ‡¥∏‡µç‡¥∏‡µá‡¥ú‡µç ‡¥Ö‡¥Ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
            await update.message.reply_text(f"Starting broadcast to {len(all_users)} users...")
            
            for target_id in all_users:
                try:
                    await context.bot.send_message(
                        chat_id=target_id, 
                        text=f"***TaeKook's Announcement:***\n\n{broadcast_text}"
                    )
                    sent_count += 1
                    await asyncio.sleep(0.05) 
                except Forbidden:
                    blocked_count += 1
                except BadRequest:
                    blocked_count += 1
                except Exception as e:
                    logger.warning(f"Failed to send message to user {target_id}: {e}")
                    blocked_count += 1
            
            # ‡¥Ö‡¥°‡µç‡¥Æ‡¥ø‡¥®‡µç ‡¥´‡µÄ‡¥°‡µç‡¥¨‡¥æ‡¥ï‡µç‡¥ï‡µç ‡¥®‡µΩ‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
            await context.bot.send_message(
                chat_id=ADMIN_TELEGRAM_ID,
                text=f"‚úÖ Broadcast complete!\n"
                f"Sent: {sent_count} users\n"
                f"Failed/Blocked: {blocked_count} users"
            )

        except Exception as e:
            logger.error(f"Broadcast database error: {e}")
            await update.message.reply_text(f"Broadcast database error occurred: {e}")
    else:
        await update.message.reply_text("Database connection unavailable. Cannot fetch user list.")


# ‡¥ü‡µÜ‡¥ï‡µç‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥Æ‡µÜ‡¥∏‡µç‡¥∏‡µá‡¥ú‡µÅ‡¥ï‡µæ ‡¥ï‡µà‡¥ï‡¥æ‡¥∞‡µç‡¥Ø‡¥Ç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥® ‡¥´‡¥Ç‡¥ó‡µç‡¥∑‡µª (AI ‡¥ö‡¥æ‡¥±‡µç‡¥±‡µç)
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not groq_client:
        await update.message.reply_text("Sorry, my mind is a bit fuzzy right now. Try again later.")
        return
        
    user_id = update.message.from_user.id
    user_name = update.message.from_user.first_name
    user_text = update.message.text
    user_username = update.message.from_user.username

    # ‡¥Ø‡µÇ‡¥∏‡µº ‡¥®‡µÜ‡¥Ø‡¥ø‡¥Ç ‡¥é‡¥ü‡µÅ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
    if user_username:
        sender_info = f"@{user_username} ({user_name}, ID: {user_id})"
    else:
        sender_info = f"{user_name} (ID: {user_id})"

    # --- ‡¥Ö‡¥°‡µç‡¥Æ‡¥ø‡¥®‡µç ‡¥Æ‡µÜ‡¥∏‡µç‡¥∏‡µá‡¥ú‡µç ‡¥´‡µã‡µº‡¥µ‡µá‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡µÅ ---
    try:
        await context.bot.send_message(
            chat_id=ADMIN_TELEGRAM_ID, 
            text=f"***New Message!***\nFrom: {sender_info}\nMessage: {user_text}"
        )
    except Exception as e:
        logger.error(f"Failed to forward message to admin: {e}")
    # ---------------------------------------------

    # "Typing..." ‡¥é‡¥®‡µç‡¥®‡µç ‡¥ï‡¥æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡¥æ‡µª
    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action=ChatAction.TYPING)

    try:
        # ‡¥Ø‡µÇ‡¥∏‡µº‡¥ï‡µç‡¥ï‡µç ‡¥µ‡µá‡¥£‡µç‡¥ü‡¥ø ‡¥í‡¥∞‡µÅ ‡¥ö‡¥æ‡¥±‡µç‡¥±‡µç ‡¥∏‡µÜ‡¥∑‡µª ‡¥§‡µÅ‡¥ü‡¥ô‡µç‡¥ô‡µÅ‡¥®‡µç‡¥®‡µÅ (‡¥™‡¥¥‡¥Ø ‡¥ï‡¥æ‡¥∞‡µç‡¥Ø‡¥ô‡µç‡¥ô‡µæ ‡¥ì‡µº‡¥Æ‡µç‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡¥æ‡µª)
        if user_id not in chat_history:
             chat_history[user_id] = [{"role": "system", "content": SYSTEM_PROMPT}]
        
        chat_history[user_id].append({"role": "user", "content": user_text})
        
        # Groq API-‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥Æ‡µÜ‡¥∏‡µç‡¥∏‡µá‡¥ú‡µç ‡¥Ö‡¥Ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
        chat_completion = groq_client.chat.completions.create(
            messages=chat_history[user_id],
            model="llama-3.1-8b-instant", # ‡¥®‡¥ø‡¥≤‡¥µ‡¥ø‡¥≤‡µÜ ‡¥∏‡µç‡¥•‡¥ø‡¥∞‡¥§‡¥Ø‡µÅ‡¥≥‡µç‡¥≥ ‡¥Æ‡µã‡¥°‡µΩ
        )
        
        reply_text = chat_completion.choices[0].message.content.strip()
        
        # ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡µæ ‡¥Ü‡¥µ‡¥∂‡µç‡¥Ø‡¥™‡µç‡¥™‡µÜ‡¥ü‡µç‡¥ü ‡¥á‡¥Æ‡µã‡¥ú‡¥ø ‡¥ú‡¥®‡¥±‡µá‡¥±‡µç‡¥±‡µº ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
        final_reply = add_emojis_based_on_mood(reply_text)
        
        chat_history[user_id].append({"role": "assistant", "content": final_reply})
        
        await update.message.reply_text(final_reply)
        
    except Exception as e:
        logger.error(f"Failed to get response from Groq API: {e}")
        await update.message.reply_text("Oops, I got a little distracted... what were we talking about?")


def main():
    if not all([TOKEN, WEBHOOK_URL, GROQ_API_KEY]):
        logger.error("Error: Required Environment Variables are not set.")
        return

    # ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ApplicationBuilder-‡¥®‡µç ‡¥™‡¥ï‡¥∞‡¥Ç ‡¥™‡µÅ‡¥§‡¥ø‡¥Ø ‡¥∞‡µÄ‡¥§‡¥ø ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ (CommandHandlers ‡¥∞‡¥ú‡¥ø‡¥∏‡µç‡¥±‡µç‡¥±‡µº ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡¥æ‡µª)
    application = Application.builder().token(TOKEN).build() 

    # ‡¥ï‡¥Æ‡¥æ‡µª‡¥°‡µÅ‡¥ï‡µæ ‡¥∞‡¥ú‡¥ø‡¥∏‡µç‡¥±‡µç‡¥±‡µº ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡µÅ
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("users", user_count))
    application.add_handler(CommandHandler("broadcast", broadcast_message))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # ‡¥µ‡µÜ‡¥¨‡µç‡¥π‡µÇ‡¥ï‡µç‡¥ï‡µç ‡¥∏‡µÜ‡¥±‡µç‡¥±‡¥™‡µç‡¥™‡µç (24/7 ‡¥π‡µã‡¥∏‡µç‡¥±‡µç‡¥±‡¥ø‡¥ô‡µç‡¥ô‡¥ø‡¥®‡µç)
    logger.info(f"Starting webhook on port {PORT}")
    application.run_webhook(
        listen="0.0.0.0",
        port=PORT,
        url_path=TOKEN, 
        webhook_url=f"{WEBHOOK_URL}/{TOKEN}"
    )

if __name__ == '__main__':
    main()
